; Script generated by Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
; And custom code added for kmagent specific requirements.

#define MyAppName "kmagent"
#define MyAppPublisher "KloudMate"
#define MyAppURL "https://kloudmate.com"
#define MyAppExeName "kmagent.exe"
#define MyServiceName "kmagent"
#define MyServiceDisplayName "Kloudmate Monitoring Service"
#define MyBuildConfigDirName "win"
#define MyConfigSourceDir "source"
#define MyConfigFileName "agent.yaml"
// Define the base config directory using a constant for easy modification
#define MyConfigDirBase "{commonappdata}\{#MyAppName}"
// Define the full config file path using the base dir constant
#define MyConfigFilePath "{#MyConfigDirBase}\{#MyConfigFileName}"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same
; AppId value in other installers.
; (Use a new GUID if you reuse this script for another application.)
AppId=f0bcc1d7-e444-47ea-b6ce-18c671f5889d
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DefaultGroupName={#MyAppName}
AllowNoIcons=yes
; Setup needs admin rights to install service and write to ProgramData
PrivilegesRequired=admin
OutputDir=.
OutputBaseFilename=kmagent-{#MyAppVersion}-setup
Compression=lzma
SolidCompression=yes
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Files]
; Install the main application executable
Source: "{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
; NOTE: Add any other necessary files like DLLs, resource files etc. here
; Example: Source: "{#MyConfigSourceDir}\some_other_file.dll"; DestDir: "{app}"; Flags: ignoreversion

; The config directory will be created by the code section if needed,
; but specifying it here helps with clean uninstall if code fails.
; We add the 'deleteafterinstall' flag because the actual file is generated by code.
; Source: {#MyConfigFilePath}; DestDir: {#MyConfigDirBase}; Attribs: hidden; Flags: uninsneveruninstall createsuperuserowneracl deleteafterinstall onlyifdoesntexist

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
; Optional: Add uninstall entry icon
Name: "{group}\Uninstall {#MyAppName}"; Filename: "{uninstallexe}"

[UninstallDelete]
; Clean up the config directory and installation directory on uninstall
Type: filesandordirs; Name: "{commonappdata}\{#MyAppName}"
Type: filesandordirs; Name: "{app}"

; =============================================================================
; Custom Code Section for API Key Prompt, Config Generation, and Service Mgmt
; =============================================================================
[Code]
var
  ConfigPage: TInputQueryWizardPage;
  // Add more variables for optional fields if needed
  // DockerModeCheckbox: TCheckBox;
  // UpdateEndpointEdit: TEdit;
  StoredAPIKey: String;
  StoredCollectorEndpoint: String;
  // StoredDockerMode: Boolean;
  // StoredUpdateEndpoint: String;

// Function to run external commands (like sc.exe) silently
function ExecCmd(FileName, Params, WorkingDir: String; Wait: Boolean; HideWindow: Boolean): Integer;
var
  Cmd: String;
  ResultCode: Integer;
  WaitUntilTerminated: Boolean;
  ShowWindowState: Integer;
begin
  Log(Format('Executing: "%s" %s', [FileName, Params]));
  Cmd := '"' + FileName + '" ' + Params; // Ensure filename is quoted

  if HideWindow then
    ShowWindowState := SW_HIDE
  else
    ShowWindowState := SW_SHOWNORMAL; // or SW_SHOWMINNOACTIVE etc.

  WaitUntilTerminated := Wait;

  if Exec(FileName, Params, WorkingDir, ShowWindowState, ewWaitUntilTerminated, ResultCode) then
  begin
    Log(Format('Execution successful. Exit code: %d', [ResultCode]));
    Result := ResultCode;
  end
  else
  begin
    Log(Format('Execution failed. Error code: %d', [SysErrorMessage(ResultCode)]));
    Result := -1; // Indicate failure to execute
  end;
end;

// Function to check if a service exists
function ServiceExists(const ServiceName: string): Boolean;
var
  ResultCode: Integer;
  ExecOutput: string; // Not used here, but could capture output if needed
begin
  // Use 'sc query' which returns non-zero if service doesn't exist
  ResultCode := ExecCmd('sc.exe', 'query "' + ServiceName + '"', '', True, True);
  Result := (ResultCode = 0); // SC query returns 0 if service exists (even if stopped)
  if Result then
    Log(Format('Service "%s" exists.', [ServiceName]))
  else
    Log(Format('Service "%s" does not exist.', [ServiceName]));
end;

// Function to stop a service
procedure StopService(const ServiceName: string);
var
  ResultCode: Integer;
begin
  if ServiceExists(ServiceName) then
  begin
    Log(Format('Stopping service: %s', [ServiceName]));
    ResultCode := ExecCmd('sc.exe', 'stop "' + ServiceName + '"', '', True, True);
    if ResultCode <> 0 then
      Log(Format('Failed to stop service %s. Result code: %d. It might have already been stopped.', [ServiceName, ResultCode]))
    else
      Log(Format('Service %s stop command issued.', [ServiceName]));
    // Add a small delay to allow the service to stop
    Sleep(2000);
  end
  else
  begin
    Log(Format('Service %s does not exist, skipping stop.', [ServiceName]));
  end;
end;

// Function to delete a service
procedure DeleteService(const ServiceName: string);
var
  ResultCode: Integer;
begin
  if ServiceExists(ServiceName) then
  begin
    Log(Format('Deleting service: %s', [ServiceName]));
    ResultCode := ExecCmd('sc.exe', 'delete "' + ServiceName + '"', '', True, True);
    if ResultCode <> 0 then
      Log(Format('Failed to delete service %s. Result code: %d', [ServiceName, ResultCode]))
    else
      Log(Format('Service %s deleted.', [ServiceName]));
  end
  else
  begin
     Log(Format('Service %s does not exist, skipping delete.', [ServiceName]));
  end;
end;

// Function to install the service
function InstallService(): Boolean;
var
  ServicePath: String;
  ConfigPath: String;
  BinPath: String;
  Params: String;
  ResultCode: Integer;
begin
  Result := False; // Assume failure
  ServicePath := ExpandConstant('{app}\kmagent.exe');
  ConfigPath := ExpandConstant('{commonappdata}\kmagent\agent.yaml');
  BinPath := Format('"%s --agent-config \"%s\" start"', [ServicePath, ConfigPath]);

  if ServiceExists('kmagent') then
  begin
    Log('Service already exists. Stopping and deleting before reinstalling.');
    StopService('kmagent');
    DeleteService('kmagent');
    Sleep(1000);
  end;

  Log('Creating service: kmagent');
  Log(Format('Service Executable: %s', [ServicePath]));
  Log(Format('Config File Path: %s', [ConfigPath]));
  Log(Format('Service binPath: %s', [BinPath]));

  Params := Format('create "kmagent" binPath= %s start= auto DisplayName= "Kloudmate Monitoring Service"', [BinPath]);
  ResultCode := ExecCmd('sc.exe', Params, '', True, True);

  if ResultCode = 0 then
  begin
    Log('Service created successfully.');
    ExecCmd('sc.exe', 'description "kmagent" "Monitors system metrics and logs using KMAgent."', '', True, True);
    Result := True;
  end
  else
  begin
    Log(Format('Failed to create service. SC exit code: %d', [ResultCode]));
    MsgBox(Format('Failed to create the kmagent service. Please check the logs or try running the installer as Administrator. Error code: %d', [ResultCode]), mbError, MB_OK);
  end;
end;


// Function to start the service
function StartSvc(): Boolean;
var
  Params: String;
  ResultCode: Integer;
begin
  Result := False; // Assume failure
  Log('Starting service: {#MyServiceName}');
  Params := Format('start "{#MyServiceName}"', []);
  ResultCode := ExecCmd('sc.exe', Params, '', True, True);

  if ResultCode = 0 then
  begin
    Log('Service started successfully.');
    Result := True;
  end
  else
  begin
    // Error 1056: An instance of the service is already running. Not a failure.
    // Error 1060: The specified service does not exist as an installed service. (Shouldn't happen if InstallService succeeded)
    if ResultCode = 1056 then
    begin
      Log('Service was already running.');
      Result := True; // Treat as success
    end
    else
    begin
      Log(Format('Failed to start service. SC exit code: %d', [ResultCode]));
      MsgBox(Format('Failed to start the {#MyServiceName} service. Please check the service manager (services.msc) and application logs for details. Error code: %d', [ResultCode]), mbError, MB_OK);
    end;
  end;
end;

// Function to generate the agent.yaml config file
function GenerateConfigFile(): Boolean;
var
  ConfigLines: TStringList;
  ConfigDir: String;
  ConfigPath: String;
begin
  Result := False;
  ConfigDir := ExpandConstant('{commonappdata}\kmagent');
  ConfigPath := ConfigDir + '\agent.yaml';

  Log(Format('Generating config file at: %s', [ConfigPath]));

  if not ForceDirectories(ConfigDir) then
  begin
    Log(Format('Error: Could not create configuration directory: %s', [ConfigDir]));
    MsgBox(Format('Failed to create the configuration directory: %s. Please check permissions.', [ConfigDir]), mbError, MB_OK);
    Exit;
  end;

  ConfigLines := TStringList.Create;
  try
    ConfigLines.Add(Format('api-key: "%s"', [StoredAPIKey]));
    ConfigLines.Add(Format('collector-endpoint: "%s"', [StoredCollectorEndpoint]));

    Log('Generated config content:');
    Log(ConfigLines.Text);

    ConfigLines.SaveToFile(ConfigPath);
    Log('Config file saved successfully.');
    Result := True;
  except
    Log(Format('Error generating or saving config file: %s.', [ConfigPath]));
    MsgBox(Format('Failed to generate the configuration file %s.', [ConfigPath]), mbError, MB_OK);
  end;
  ConfigLines.Free;
end;



// --- Wizard Page Creation and Handling ---

procedure InitializeWizard;
begin
  Log('Initializing wizard...');
  // Create the custom page after the directory selection page
  ConfigPage := CreateInputQueryPage(wpSelectDir,
    '{#MyAppName} Configuration', 'Please provide the required configuration details.',
    'Enter the necessary information for {#MyAppName} to connect.');

  // Add input fields to the page
  ConfigPage.Add('API Key:', False); // False = not password

  ConfigPage.Add('Collector Endpoint (e.g., https://collector.example.com:4317):', False);

  // --- Add more controls for optional parameters if needed ---
  // ConfigPage.Add('Enable Docker Mode:', True); // True = creates a checkbox below
  // DockerModeCheckbox := ConfigPage.Checkboxes[0]; // Get checkbox control (index starts from 0 for checkboxes)

  // ConfigPage.Add('Update Endpoint (Optional):', False);
  // UpdateEndpointEdit := ConfigPage.Edits[2]; // Index continues based on number of Edits added

  Log('Custom configuration page created.');
end;

function NextButtonClick(CurPageID: Integer): Boolean;
var
  ErrMsg: String;
begin
  Result := True; // Assume okay to proceed
  if CurPageID = ConfigPage.ID then
  begin
    Log('Next button clicked on Config Page.');
    ErrMsg := '';
    // Validate mandatory fields
    if Trim(ConfigPage.Values[0]) = '' then
      ErrMsg := AddPeriod(ErrMsg) + ' API Key cannot be empty';

    if Trim(ConfigPage.Values[1]) = '' then
      ErrMsg := AddPeriod(ErrMsg) + ' Collector Endpoint cannot be empty';

    // Add validation for other fields if needed

    if ErrMsg <> '' then
    begin
      MsgBox('Please correct the following errors:' + #13#10 + ErrMsg, mbError, MB_OK);
      Result := False; // Stay on the current page
    end
    else
    begin
      // Store the values in global variables for later use
      StoredAPIKey := Trim(ConfigPage.Values[0]);
      StoredCollectorEndpoint := Trim(ConfigPage.Values[1]);

      // StoredDockerMode := DockerModeCheckbox.Checked;
      // StoredUpdateEndpoint := Trim(UpdateEndpointEdit.Text);
      Log('Configuration values captured.');
      Result := True; // Proceed to the next page
    end;
  end;
end;

// --- Installation Steps ---

procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssPostInstall then
  begin
    Log('Current Step: Post Install');

    // 1. Generate the configuration file
    if not GenerateConfigFile() then
    begin
      // Error message already shown by GenerateConfigFile
      Log('Aborting service installation due to config file generation failure.');
      // You might want to decide if the installation should fail entirely here.
      // For now, we just skip service installation/start.
    end
    else
    begin
      // 2. Install the Windows service
      if not InstallService() then
      begin
        // Error message already shown by InstallService
        Log('Service installation failed. Skipping service start.');
      end
      else
      begin
        // 3. Start the service (only if install succeeded)
        StartSvc(); // Warnings shown by StartSvc if it fails
      end;
    end;
  end;
end;

// --- Uninstallation Steps ---

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
  if CurUninstallStep = usUninstall then
  begin
    Log('Current Uninstall Step: Uninstall');
    // Stop and delete the service before files are removed
    StopService('{#MyServiceName}');
    DeleteService('{#MyServiceName}');
  end;
end;